package main

import (
	"flag"
	"fmt"
	"goi18n/embedfile"
	"goi18n/utils"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"unsafe"
)

var DEFAULT_LANG string
var (
	FLAG_DIR       string
	FLAG_OUT       string
	FLAG_SORT_KEY  int
	FLAG_DESC      string
	FLAG_SORT_LANG string
)

const LANG_PREFIX = "I18N_"

func init() {
	flag.StringVar(&FLAG_DESC, "desc", "", `为语言对象增加注释,默认全部,可多选, 示例: -desc zh_CN,en_US`)
	flag.StringVar(&FLAG_DIR, "dir", "./lang/csv", `数据源-CSV目录, 示例: -dir ./lang/csv`)
	flag.StringVar(&FLAG_OUT, "out", "./lang", `输出目录, 示例: -out ./lang`)
	flag.StringVar(&FLAG_SORT_LANG, "sort_lang", "", `语言排序类型,默认ASCII码降序,第一个默认为默认语言, 示例: -sort_lang zh_CN,en_US`)
	flag.IntVar(&FLAG_SORT_KEY, "sort_key", 0, `词条排序类型，0: 不排序，1: Ascll码升序，2: Ascll码降序，默认不排序，示例: -sort_key 0`)

	flag.Parse()
}

// langkey eg:zh_CN
//
// code,key,langkey1,langkey2,...
// code1,key1,keylang1,keylang2,...
// code2,key2,keylang1,keylang2,...

func main() {
	fmt.Println("goi18n RUN")
	tocopyFile := embedfile.LANG.List()
	for _, filename := range tocopyFile {
		fmt.Println("开始复制文件:" + filename)
		err := embedfile.LANG.Copy(filepath.Join(FLAG_OUT, filename), filename)
		if err != nil {
			panic(err)
		}
	}
	fileList := GetFileList(FLAG_DIR)

	kvMap := make(map[string]map[string]string)
	codeMap := make(map[string]uint32)
	langSupport := make(map[string]struct{})
	var keySort []string

	for _, fileName := range fileList {
		fmt.Println("开始载入文件:" + fileName)
		info := utils.ReadCSV(fileName, kvMap, codeMap)
		if info == nil || len(info.Keys) == 0 {
			continue
		}
		for _, langstr := range info.Langs {
			langSupport[langstr] = struct{}{}
		}
		keySort = append(keySort, info.Keys...)
	}

	if len(langSupport) == 0 {
		panic("There is no language support")
	}
	langs := make([]string, 0, len(langSupport))
	if len(FLAG_SORT_LANG) == 0 {
		for langstr := range langSupport {
			langs = append(langs, langstr)
		}
		// Ascii码降序
		sort.Slice(langs, func(i, j int) bool {
			return langs[i] > langs[j]
		})
	} else {
		sortLang := strings.Split(FLAG_SORT_LANG, ",")
		if len(sortLang) != len(langSupport) {
			panic("sort_lang length is not equal to langSupport")
		}
		for _, langstr := range sortLang {
			if _, ok := langSupport[langstr]; ok {
				langs = append(langs, langstr)
			} else {
				panic(langstr + " is not in langSupport")
			}
		}
	}

	switch FLAG_SORT_KEY {
	case 1:
		sort.Slice(keySort, func(i, j int) bool {
			return keySort[i] < keySort[j]
		})
	case 2:
		sort.Slice(keySort, func(i, j int) bool {
			return keySort[i] > keySort[j]
		})
	}

	DEFAULT_LANG = langs[0]

	fmt.Println("默认语言:", DEFAULT_LANG)

	build_key_go(langs, keySort, kvMap)
	build_data_go(langs, keySort, kvMap)
	fmt.Println("goi18n END")
	fmt.Println("Program completed. Press any key to exit.")

	var input string
	fmt.Scanln(&input) // 等待用户输入，然后程序会结束
}

func build_key_go(langs, keySort []string, kvMap map[string]map[string]string) {
	genFs := func(name string) *os.File {
		f, err := os.Create(filepath.Join(FLAG_OUT, name+".go"))
		if err != nil {
			panic(err)
		}
		return f
	}
	mapf := genFs("map")
	defer mapf.Close()
	keyf := genFs("key")
	defer keyf.Close()

	write := func(f *os.File, s string) {
		b := unsafe.Slice(unsafe.StringData(s), len(s))
		n, err := f.Write(b)
		if err != nil {
			panic(err)
		}
		if n != len(s) {
			panic("not all data was written")
		}
	}

	var langs1, langs2, langs3 strings.Builder
	for i, locale := range langs {
		varName := LANG_PREFIX + strings.ToUpper(formatLocale(locale))
		langs1.WriteString(fmt.Sprintf("\n	%s = %s", varName, strconv.Quote(locale)))
		langs2.WriteString(fmt.Sprintf("\n	%s_ID = %d", varName, i))
		langs3.WriteString(fmt.Sprintf("\n	%s,", varName))
	}

	write(keyf, fmt.Sprintf(`/*
* Code generated by github.com/wilhuang/goi18n. DO NOT EDIT.
* version: 1.0.0
* date: 2024-04-24
*/
package lang

const (%s
)
const (%s
	I18N_LEN = %d // 不包含key，同时也是KeyId
)

var _LANGS = [I18N_LEN]string{%s
}

const (
	_start Code = 1000 + iota`,
		langs1.String(), langs2.String(), len(langs), langs3.String()))

	write(mapf, `/*
* Code generated by github.com/wilhuang/goi18n. DO NOT EDIT.
* version: 1.0.0
* date: 2024-04-24
*/
package lang

func init() {
	r := newDoubleLinkNode()`)

	langDescSet := make(map[string]struct{})
	if len(FLAG_DESC) > 0 {
		for _, langstr := range strings.Split(FLAG_DESC, ",") {
			langDescSet[langstr] = struct{}{}
		}
	}
	for _, key := range keySort {
		write(mapf, fmt.Sprintf("\n	r.Add(\"%s\", %s)", key, key))
		write(keyf, "\n	"+key)
		for _, langstr := range langs {
			if len(langDescSet) > 0 {
				if _, ok := langDescSet[langstr]; !ok {
					continue
				}
			}
			desc := strings.ReplaceAll(kvMap[key][langstr], "\n", "")
			if len(desc) == 0 {
				desc = "nil"
			}
			write(keyf, " // "+desc)
		}
	}
	write(keyf, "\n	_end\n)\n")
	write(mapf, "\n	r.End()\n}\n")
}

func formatLocale(locale string) string {
	re := regexp.MustCompile("_+")
	locale = strings.ReplaceAll(locale, "-", "_")
	locale = strings.ReplaceAll(locale, " ", "_")

	locale = re.ReplaceAllString(locale, "_")
	// 移除首尾下划线
	return strings.Trim(locale, "_")
}

func build_data_go(langs, keySort []string, kvMap map[string]map[string]string) {
	genFs := func(name string) *os.File {
		f, err := os.Create(filepath.Join(FLAG_OUT, name+".go"))
		if err != nil {
			panic(err)
		}
		return f
	}
	dataf := genFs("data")
	defer dataf.Close()

	write := func(s string) {
		b := unsafe.Slice(unsafe.StringData(s), len(s))
		n, err := dataf.Write(b)
		if err != nil {
			panic(err)
		}
		if n != len(s) {
			panic("not all data was written")
		}
	}

	builders := make([]strings.Builder, len(langs)+1)
	for _, key := range keySort {
		builders[len(langs)].WriteString(strconv.Quote(key) + ",")
		for i, langstr := range langs {
			builders[i].WriteString(strconv.Quote(kvMap[key][langstr]) + ",")
		}
	}

	write(`/*
* Code generated by github.com/wilhuang/goi18n. DO NOT EDIT.
* version: 1.0.0
* date: 2024-04-24
*/
package lang

var entries=[I18N_LEN+1][_end-_start-1]string{
`)
	for i := range langs {
		write("	{")
		write(builders[i].String())
		write("},\n")
	}
	write("	{")
	write(builders[len(langs)].String())
	write("},\n")
	write("}\n")
}

func GetFileList(dir string) []string {
	var fileList []string
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			fmt.Println(err.Error())
			return err
		}
		if !info.IsDir() {
			if strings.HasSuffix(strings.ToLower(path), "csv") {
				fileList = append(fileList, path)
			}
		}
		return nil
	})
	if err != nil {
		fmt.Println("Error walking the path:", err)
	}

	if len(fileList) == 0 {
		fmt.Println("There is no CSV file in the directory")
	}
	return fileList
}
