package main

import (
	"flag"
	"fmt"
	"goi18n/embedfile"
	"goi18n/utils"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
)

var DEFAULT_LANG string
var (
	FLAG_DIR  string
	FLAG_OUT  string
	FLAG_SORT int
	FLAG_DESC string
)

const LANG_PREFIX = "I18N_"

func init() {
	flag.StringVar(&FLAG_DESC, "desc", "", `为语言对象增加注释,默认全部,可多选, 示例: -desc zh_CN,en_US`)
	flag.StringVar(&FLAG_DIR, "dir", "./lang/csv", `数据源-CSV目录, 示例: -dir ./lang/csv`)
	flag.StringVar(&FLAG_OUT, "out", "./lang", `输出目录, 示例: -out ./lang`)
	flag.IntVar(&FLAG_SORT, "sort", 0, `词条排序类型, 示例: -sort
0: 不排序
1: Ascll码升序(单表)
2: Ascll码降序(单表)
3: Ascll码升序(全局)
4: Ascll码降序(全局)`)
}

// langkey eg:zh_CN
//
// code,key,langkey1,langkey2,...
// code1,key1,keylang1,keylang2,...
// code2,key2,keylang1,keylang2,...

func main() {
	fmt.Println("goi18n RUN")
	tocopyFile := embedfile.LANG.List()
	for _, filename := range tocopyFile {
		fmt.Println("开始复制文件:" + filename)
		data, err := embedfile.LANG.ReadFile(filename)
		if err != nil {
			panic(err)
		}
		err = output(FLAG_OUT, filename, string(data))
		if err != nil {
			panic(err)
		}
	}
	fileList := GetFileList(FLAG_DIR)

	kvMap := make(map[string]map[string]string)
	codeMap := make(map[string]uint32)
	langSupport := make(map[string]struct{})
	var keySort []string

	for _, fileName := range fileList {
		fmt.Println("开始载入文件:" + fileName)
		info := utils.ReadCSV(fileName, kvMap, codeMap)
		if info == nil || len(info.Keys) == 0 {
			continue
		}
		for _, langstr := range info.Langs {
			langSupport[langstr] = struct{}{}
		}
		keySort = append(keySort, info.Keys...)
	}
	var langs []string
	for langstr := range langSupport {
		langs = append(langs, langstr)
	}
	if len(langs) == 0 {
		return
	}
	sort.Slice(langs, func(i, j int) bool {
		return langs[i] > langs[j]
	})

	DEFAULT_LANG = langs[0]

	fmt.Println("默认语言:", DEFAULT_LANG)

	build_code_go(langs, keySort, kvMap)
	build_key_go(langs, keySort, kvMap)
	fmt.Println("goi18n END")
	fmt.Println("Program completed. Press any key to exit.")

	var input string
	fmt.Scanln(&input) // 等待用户输入，然后程序会结束
}

func build_code_go(langs, keySort []string, kvMap map[string]map[string]string) {
	var langsBuilder, initBuilder, keyEnumBuilder, keyMapBuilder strings.Builder

	langDescSet := make(map[string]struct{})
	if len(FLAG_DESC) > 0 {
		for _, langstr := range strings.Split(FLAG_DESC, ",") {
			langDescSet[langstr] = struct{}{}
		}
	}

	for _, key := range keySort {
		fmt.Fprintf(&keyMapBuilder, "\n	r.Add(\"%s\", %s)", key, key)
		keyEnumBuilder.WriteString("\n	" + key)
		for _, langstr := range langs {
			if len(langDescSet) > 0 {
				if _, ok := langDescSet[langstr]; !ok {
					continue
				}
			}
			desc := strings.ReplaceAll(kvMap[key][langstr], "\n", "")
			if len(desc) == 0 {
				desc = "nil"
			}
			keyEnumBuilder.WriteString(" // " + desc)
		}
	}
	for _, locale := range langs {
		varName := LANG_PREFIX + strings.ToUpper(formatLocale(locale))
		langsBuilder.WriteString(fmt.Sprintf("\n	%s = %s", varName, strconv.Quote(locale)))
		initBuilder.WriteString(fmt.Sprintf("\n	%s,", varName))
	}

	enumFile := fmt.Sprintf(`/*
* Code generated by github.com/wilhuang/goi18n. DO NOT EDIT.
* version: 1.0.0
* date: 2024-04-24
*/
package lang

const _NUM_LANG uint16 = %d // 不包含key


const (%s
)

var _default_langsort = [_NUM_LANG]string{%s
}

const (
	_start Code = 1000 + iota%s
	_end
)
`, len(langs),
		langsBuilder.String(),
		initBuilder.String(),
		keyEnumBuilder.String())

	mapFile := fmt.Sprintf(`/*
* Code generated by github.com/wilhuang/goi18n. DO NOT EDIT.
* version: 1.0.0
* date: 2024-04-24
*/
package lang

func init() {
	r := newDoubleLinkNode()%s
	r.End()
}
`, keyMapBuilder.String())

	err := output(FLAG_OUT, "enum.go", enumFile)
	if err != nil {
		panic(err)
	}

	err = output(FLAG_OUT, "map.go", mapFile)
	if err != nil {
		panic(err)
	}
}

func formatLocale(locale string) string {
	re := regexp.MustCompile("_+")
	locale = strings.ReplaceAll(locale, "-", "_")
	locale = strings.ReplaceAll(locale, " ", "_")

	locale = re.ReplaceAllString(locale, "_")
	// 移除首尾下划线
	return strings.Trim(locale, "_")
}

func build_key_go(langs, keySort []string, kvMap map[string]map[string]string) {
	builders := make([]strings.Builder, len(langs)+1)
	for _, key := range keySort {
		builders[len(langs)].WriteString(strconv.Quote(key) + ",")
		for i, langstr := range langs {
			builders[i].WriteString(strconv.Quote(kvMap[key][langstr]) + ",")
		}
	}

	var strBuilder strings.Builder
	strBuilder.WriteString(`/*
* Code generated by github.com/wilhuang/goi18n. DO NOT EDIT.
* version: 1.0.0
* date: 2024-04-24
*/
package lang

var entries=[_NUM_LANG+1][_end-_start-1]string{
`)
	strBuilder.WriteString("	{")
	strBuilder.WriteString(builders[len(langs)].String())
	strBuilder.WriteString("},\n")

	for i := range langs {
		strBuilder.WriteString("	{")
		strBuilder.WriteString(builders[i].String())
		strBuilder.WriteString("},\n")
	}
	strBuilder.WriteString("}")

	f, err := os.OpenFile(filepath.Join(FLAG_OUT, "data.go"), os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	_, err = f.WriteString(strBuilder.String())
	if err != nil {
		panic(err)
	}
}

func GetFileList(dir string) []string {
	var fileList []string
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			fmt.Println(err.Error())
			return err
		}
		if !info.IsDir() {
			if strings.HasSuffix(strings.ToLower(path), "csv") {
				fileList = append(fileList, path)
			}
		}
		return nil
	})
	if err != nil {
		fmt.Println("Error walking the path:", err)
	}

	if len(fileList) == 0 {
		fmt.Println("There is no CSV file in the directory")
	}
	return fileList
}

func output(dir, filename string, str string) error {
	f, err := os.OpenFile(filepath.Join(dir, filename), os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777)
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = f.WriteString(str)
	if err != nil {
		return err
	}

	return nil
}
