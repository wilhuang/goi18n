/*
 * Code generated by github.com/wilhuang/goi18n. DO NOT EDIT.
 * version: 1.0.0
 * date: 2024-04-24
 */
package lang

import (
	"fmt"
)

const (
	ERR_CODE_UNKNOW Code = iota
)

// 使用 radix 树（或称为字典树）来存储字符串前缀
type doubleLinkNode struct {
	parent *doubleLinkNode
	child  map[rune]*doubleLinkNode
	code   Code
}

func newDoubleLinkNode() *doubleLinkNode {
	return &doubleLinkNode{
		child: make(map[rune]*doubleLinkNode),
	}
}

func (r *doubleLinkNode) Add(s string, code Code) {
	curr := r
	for _, ch := range s {
		if curr.child != nil {
			if child, ok := curr.child[ch]; ok {
				curr = child
				continue
			}
		}
		newNode := &doubleLinkNode{
			parent: curr,
			child:  make(map[rune]*doubleLinkNode),
		}
		curr.child[ch] = newNode
		curr = newNode
	}
	curr.code = code
}

func (r *doubleLinkNode) End() {
	traverseDelLeaf(r)
	r.Gen()
}

var root *node

type node struct {
	child map[rune]*node
	code  Code
}

func (r *doubleLinkNode) Gen() {
	curr := r
	root = &node{
		child: make(map[rune]*node, len(curr.child)),
		code:  curr.code,
	}
	traverse(r, root)
}

func traverse(n *doubleLinkNode, nc *node) {
	if n == nil {
		return
	}
	// 遍历子节点
	for ch, child := range n.child {
		newNode := &node{
			code: child.code,
		}
		if len(child.child) > 0 {
			newNode.child = make(map[rune]*node, len(child.child))
			traverse(child, newNode)
		}
		nc.child[ch] = newNode
	}
}

func traverseDelLeaf(n *doubleLinkNode) {
	if n == nil {
		return
	}
	if len(n.child) == 0 && n.parent.code == 0 && len(n.parent.child) == 1 {
		n.parent.code = n.code
		n.parent.child = nil

		traverseDelLeaf(n.parent.parent)
		// 从叶子节点开始裁剪
		return
	}

	// 遍历子节点
	for _, child := range n.child {
		traverseDelLeaf(child)
	}
}

// ToCode 通过string类型的key值获取Code对象
func ToCode(s string) Code {
	curr := root
	for _, ch := range s {
		child, ok := curr.child[ch]
		if !ok {
			return ERR_CODE_UNKNOW
		}
		if len(child.child) == 0 {
			return child.code
		}
		curr = child
	}
	return curr.code
}

func AppendArgs(msg string, id int, args ...any) string {
	if len(args) == 0 || len(msg) == 0 {
		return msg
	}

	noLock := true
	com := make([]any, len(args))
	for idx, arg := range args {
		switch v := arg.(type) {
		case Code:
			com[idx] = v.transOne(id)
		case []Code:
			if noLock {
				_MUTEX_STEP.RLock()
				noLock = false
			}
			com[idx] = Join(v, _LANG_SEP[id], func(c Code) string {
				return c.transOne(id)
			})
		case []string:
			if noLock {
				_MUTEX_STEP.RLock()
				noLock = false
			}
			com[idx] = Join(v, _LANG_SEP[id])
		case []float64:
			if noLock {
				_MUTEX_STEP.RLock()
				noLock = false
			}
			com[idx] = Join(v, _LANG_SEP[id])
		case []float32:
			if noLock {
				_MUTEX_STEP.RLock()
				noLock = false
			}
			com[idx] = Join(v, _LANG_SEP[id])
		case []int:
			if noLock {
				_MUTEX_STEP.RLock()
				noLock = false
			}
			com[idx] = Join(v, _LANG_SEP[id])
		case []int8:
			if noLock {
				_MUTEX_STEP.RLock()
				noLock = false
			}
			com[idx] = Join(v, _LANG_SEP[id])
		case []int16:
			if noLock {
				_MUTEX_STEP.RLock()
				noLock = false
			}
			com[idx] = Join(v, _LANG_SEP[id])
		case []int32:
			if noLock {
				_MUTEX_STEP.RLock()
				noLock = false
			}
			com[idx] = Join(v, _LANG_SEP[id])
		case []int64:
			if noLock {
				_MUTEX_STEP.RLock()
				noLock = false
			}
			com[idx] = Join(v, _LANG_SEP[id])
		case []uint:
			if noLock {
				_MUTEX_STEP.RLock()
				noLock = false
			}
			com[idx] = Join(v, _LANG_SEP[id])
		case []uint8:
			if noLock {
				_MUTEX_STEP.RLock()
				noLock = false
			}
			com[idx] = Join(v, _LANG_SEP[id])
		case []uint16:
			if noLock {
				_MUTEX_STEP.RLock()
				noLock = false
			}
			com[idx] = Join(v, _LANG_SEP[id])
		case []uint32:
			if noLock {
				_MUTEX_STEP.RLock()
				noLock = false
			}
			com[idx] = Join(v, _LANG_SEP[id])
		case []uint64:
			if noLock {
				_MUTEX_STEP.RLock()
				noLock = false
			}
			com[idx] = Join(v, _LANG_SEP[id])
		default:
			com[idx] = arg
		}
	}
	if !noLock {
		_MUTEX_STEP.RUnlock()
	}
	return fmt.Sprintf(msg, com...)
}
